# 实验五 组合数据类型应用 实验报告

## 一、实验目的与任务
掌握Python组合数据类型的使用方法。要求编写简单代码实现列表、字典和元组的定义、初始化及引用。
1. 分别用列表、元组创建10个餐厅菜单项目，并进行删除、引用、排序；创建一个字典Student，描述学生基本信息个人，包括学号ID(不能用id)、姓名Name、就读学校University，并进行删除、引用、排序；随机生成包含1000个字符的字符串，然后统计每个字符的出现次数，共四个上机内容。
2. 理解列表、元数及字典的特点及定义、初始化与引用的方法，考查学生正确运用组合数据类型处理实际问题的能力。

## 二、实验环境
1. Windows操作系统或其他操作系统；
2. Python 3.9以上开发环境。

## 三、实验内容与步骤

### 1. 列表应用 (1.py)

**任务要求：**
1. 创建10个餐厅菜单项目(菜名)，作为列表menu的元素；
2. 在索引位置5和最末位上，各添加一个菜单项目；
3. 创建一个有5个凉菜的列表submenu，并用extend()函数，添加到（2）处理的列表中；
4. 对列表进行原地排序；
5. 用pop()函数取出排序后的索引为3的元素，并从列表中删除该元素；
6. 分别用in和count()判断“红烧肉”是否存在，用index()函数查找“红烧肉”首次出现列表中的位置，用remove()删除该元素；
7. 取出（6）处理后的列表中的索引为2到10的元素，原列表中的元素删除；
8. 用迭代方法，显示列表menu中的所有元素；
9. 删除列表对象menu；

**源程序 (1.py)：**
```python
# 1. 列表应用
# (1) 创建10个餐厅菜单项目
menu = ['宫保鸡丁', '鱼香肉丝', '麻婆豆腐', '红烧肉', '水煮鱼', '回锅肉', '糖醋排骨', '夫妻肺片', '口水鸡', '酸菜鱼']
print("初始列表:", menu)

# (2) 在索引位置5和最末位上，各添加一个菜单项目
menu.insert(5, '北京烤鸭')
menu.append('辣子鸡')
print("添加后:", menu)

# (3) 创建一个有5个凉菜的列表submenu，并用extend()函数，添加到（2）处理的列表中
submenu = ['拍黄瓜', '凉拌木耳', '皮蛋豆腐', '蒜泥白肉', '泡椒凤爪']
menu.extend(submenu)
print("扩展后:", menu)

# (4) 对列表进行原地排序
menu.sort()
print("排序后:", menu)

# (5) 用pop()函数取出排序后的索引为3的元素，并从列表中删除该元素
item_popped = menu.pop(3)
print(f"弹出的元素(索引3): {item_popped}")
print("弹出后:", menu)

# (6) 分别用in和count()判断“红烧肉”是否存在，用index()函数查找“红烧肉”首次出现列表中的位置，用remove()删除该元素
target = '红烧肉'
if target in menu:
    print(f"'{target}' 在列表中")
else:
    print(f"'{target}' 不在列表中")

count = menu.count(target)
print(f"'{target}' 出现次数: {count}")

if count > 0:
    idx = menu.index(target)
    print(f"'{target}' 首次出现位置: {idx}")
    menu.remove(target)
    print(f"删除 '{target}' 后:", menu)

# (7) 取出（6）处理后的列表中的索引为2到10的元素，原列表中的元素删除
# 索引2到10（包含10），切片为 [2:11]
slice_items = menu[2:11]
print("取出的元素 (索引2-10):", slice_items)
del menu[2:11]
print("删除切片后:", menu)

# (8) 用迭代方法，显示列表menu中的所有元素
print("剩余元素:")
for item in menu:
    print(item, end=' ')
print()

# (9) 删除列表对象menu
del menu
try:
    print(menu)
except NameError:
    print("menu对象已删除")
```

**运行结果：**
```
初始列表: ['宫保鸡丁', '鱼香肉丝', '麻婆豆腐', '红烧肉', '水煮鱼', '回锅肉', '糖醋排骨', '夫妻肺片', '口水鸡', '酸菜鱼']
添加后: ['宫保鸡丁', '鱼香肉丝', '麻婆豆腐', '红烧肉', '水煮鱼', '北京烤鸭', '回锅肉', '糖醋排骨', '夫妻肺片', '口水鸡', '酸菜鱼', '辣子鸡']
扩展后: ['宫保鸡丁', '鱼香肉丝', '麻婆豆腐', '红烧肉', '水煮鱼', '北京烤鸭', '回锅肉', '糖醋排骨', '夫妻肺片', '口水鸡', '酸菜鱼', '辣子鸡', '拍黄瓜', '凉拌木耳', '皮蛋豆腐', '蒜泥白肉', '泡椒凤爪']
排序后: ['凉拌木耳', '北京烤鸭', '口水鸡', '回锅肉', '夫妻肺片', '宫保鸡丁', '拍黄瓜', '水煮鱼', '泡椒凤爪', '皮蛋豆腐', '糖醋排骨', '红烧肉', '蒜泥白肉', '辣子鸡', '酸菜鱼', '鱼香肉丝', '麻婆豆腐']
弹出的元素(索引3): 回锅肉
弹出后: ['凉拌木耳', '北京烤鸭', '口水鸡', '夫妻肺片', '宫保鸡丁', '拍黄瓜', '水煮鱼', '泡椒凤爪', '皮蛋豆腐', '糖醋排骨', '红烧肉', '蒜泥白肉', '辣子鸡', '酸菜鱼', '鱼香肉丝', '麻婆豆腐']
'红烧肉' 在列表中
'红烧肉' 出现次数: 1
'红烧肉' 首次出现位置: 10
删除 '红烧肉' 后: ['凉拌木耳', '北京烤鸭', '口水鸡', '夫妻肺片', '宫保鸡丁', '拍黄瓜', '水煮鱼', '泡椒凤爪', '皮蛋豆腐', '糖醋排骨', '蒜泥白肉', '辣子鸡', '酸菜鱼', '鱼香肉丝', '麻婆豆腐']
取出的元素 (索引2-10): ['口水鸡', '夫妻肺片', '宫保鸡丁', '拍黄瓜', '水煮鱼', '泡椒凤爪', '皮蛋豆腐', '糖醋排骨', '蒜泥白肉']
删除切片后: ['凉拌木耳', '北京烤鸭', '辣子鸡', '酸菜鱼', '鱼香肉丝', '麻婆豆腐']
剩余元素:
凉拌木耳 北京烤鸭 辣子鸡 酸菜鱼 鱼香肉丝 麻婆豆腐 
menu对象已删除
```

### 2. 元组应用 (2.py)

**任务要求：**
1. 创建10个餐厅菜单项目(菜名)，作为元组menu中的元素；
2. 输出索引位置5和最末位上的项目；
3. 取出索引为2到7的元素；
4. 删除元组。

**源程序 (2.py)：**
```python
# 2. 元组应用
# (1) 创建10个餐厅菜单项目(菜名)，作为元组menu中的元素
menu = ('宫保鸡丁', '鱼香肉丝', '麻婆豆腐', '红烧肉', '水煮鱼', '回锅肉', '糖醋排骨', '夫妻肺片', '口水鸡', '酸菜鱼')
print("元组:", menu)

# (2) 输出索引位置5和最末位上的项目
print(f"索引位置5: {menu[5]}")
print(f"最末位: {menu[-1]}")

# (3) 取出索引为2到7的元素
# 索引2到7（包含7），切片为 [2:8]
slice_items = menu[2:8]
print("索引2到7的元素:", slice_items)

# (4) 删除元组
del menu
try:
    print(menu)
except NameError:
    print("元组已删除")
```

**运行结果：**
```
元组: ('宫保鸡丁', '鱼香肉丝', '麻婆豆腐', '红烧肉', '水煮鱼', '回锅肉', '糖醋排骨', '夫妻肺片', '口水鸡', '酸菜鱼')
索引位置5: 回锅肉
最末位: 酸菜鱼
索引2到7的元素: ('麻婆豆腐', '红烧肉', '水煮鱼', '回锅肉', '糖醋排骨', '夫妻肺片')
元组已删除
```

### 3. 字典应用 (3.py)

**任务要求：**
1. 创建一个字典Student，描述学生基本信息个人，包括学号ID(不能用id)、姓名Name、就读学校University；
2. 新增字典项年级Grade；
3. 分别用字典对象的items()、keys()、values()函数，并显示字典对象中的所有信息；
4. 删除字典对象中的“就读学校university”。

**源程序 (3.py)：**
```python
# 3. 字典应用
# (1) 创建一个字典Student，描述学生基本信息个人，包括学号ID(不能用id)、姓名Name、就读学校University
Student = {
    'ID': '2023001',
    'Name': '张三',
    'University': '清华大学'
}
print("初始字典:", Student)

# (2) 新增字典项年级Grade
Student['Grade'] = '大二'
print("新增年级后:", Student)

# (3) 分别用字典对象的items()、keys()、values()函数，并显示字典对象中的所有信息
print("Items:", list(Student.items()))
print("Keys:", list(Student.keys()))
print("Values:", list(Student.values()))

print("遍历信息:")
for k, v in Student.items():
    print(f"{k}: {v}")

# (4) 删除字典对象中的“就读学校university”
if 'University' in Student:
    del Student['University']
print("删除学校后:", Student)
```

**运行结果：**
```
初始字典: {'ID': '2023001', 'Name': '张三', 'University': '清华大学'}
新增年级后: {'ID': '2023001', 'Name': '张三', 'University': '清华大学', 'Grade': '大二'}
Items: [('ID', '2023001'), ('Name', '张三'), ('University', '清华大学'), ('Grade', '大二')]
Keys: ['ID', 'Name', 'University', 'Grade']
Values: ['2023001', '张三', '清华大学', '大二']
遍历信息:
ID: 2023001
Name: 张三
University: 清华大学
Grade: 大二
删除学校后: {'ID': '2023001', 'Name': '张三', 'Grade': '大二'}
```

### 4. 随机字符串统计 (4.py)

**任务要求：**
随机生成包含1000个字符的字符串，然后统计每个字符的出现次数。

**源程序 (4.py)：**
```python
# 4. 随机生成包含1000个字符的字符串，然后统计每个字符的出现次数。
import random

# 生成1000个随机字符（小写字母）
random_chars = [chr(ord('a') + random.randint(0, 25)) for _ in range(1000)]
random_string = "".join(random_chars)

print(f"生成的字符串(前50个): {random_string[:50]}...")

# 统计次数
stats = {}
for char in random_string:
    stats[char] = stats.get(char, 0) + 1

print("字符统计结果:")
# 排序输出
for char in sorted(stats.keys()):
    print(f"'{char}': {stats[char]}次")
```

**运行结果（示例）：**
```
生成的字符串(前50个): phddedmgjmsjsbjhuohncsalefpzyuokigdenaqosejcpgiggi...
字符统计结果:
'a': 31次
'b': 33次
'c': 45次
'd': 43次
'e': 42次
'f': 35次
'g': 49次
'h': 38次
'i': 34次
'j': 43次
'k': 38次
'l': 31次
'm': 45次
'n': 37次
'o': 39次
'p': 44次
'q': 37次
'r': 37次
's': 43次
't': 39次
'u': 29次
'v': 37次
'w': 31次
'x': 37次
'y': 42次
'z': 41次
```

## 四、实验结果及分析

1. **列表操作**：列表是可变的，支持原地修改（如 `sort()`, `extend()`, `del`）。在进行切片删除时，需要注意索引的范围，Python切片是左闭右开的。
2. **元组操作**：元组是不可变的，创建后不能修改元素，但可以进行索引和切片操作（切片返回新元组）。
3. **字典操作**：字典是键值对集合，键必须唯一且不可变。通过键可以快速访问、添加或删除值。
4. **随机统计**：利用 `random` 模块生成数据，结合字典进行频率统计是非常高效的方法。

## 五、实验体会

通过本次实验，我熟练掌握了Python中列表、元组和字典这三种主要组合数据类型的创建、访问、修改和删除方法。
- 列表非常灵活，适合存储有序且可变的数据集合。
- 元组适合存储不可变的数据，安全性更高。
- 字典通过键值对存储数据，查找效率高，非常适合用于统计和映射关系的数据处理。
- 此外，还练习了随机数生成和基本的字符串处理，加深了对Python内置函数的理解。
